# Бэкграунд воркеры для работы сервиса

1. [Autopayment Worker](#autopayment-worker)
2. [Expire subscriptions worker](#expire-subscriptions-worker)
3. [Expire payments worker](#expire-payments-worker)
4. [Matching pending payments worker](#matching-pending-payments-worker)
5. [Matching successful payments worker](#matching-successful-payments-worker)

---
## Autopayment worker

Воркер рекуррентных платежей.

**Описание:**

Произведение автоплатежей для подписок, у которых срок действия заканчивается в день (или ранее) запуска воркера.

**Периодичность:**

Раз в сутки по расписанию через **CRON**

**Логика:**

* выполнить выгрузку активных подписок из БД (сущность *"Subscription"*), у которых дата окончания действия (поле *"ended_at"*) <= текущей дате;
* у каждой подписки взять сохраненный идентификатор платежа провайдера (из связанной сущности *"Payment"*);
* провести платеж у провайдера;
* если платеж успешен - создать объект сущности *"Payment"* с привязкой к соответствующей подписки, обновить соответствующий объект сущности *"Subscription"* в части даты окончания действия подписки.

### Как запустить воркер

**Важно!**
Для работы воркера должен быть установлен и запущен экземпляр БД (локально или в контейнере)

1. Установите необходимые библиотеки:

```shell
pip install -r requirements.txt
```

2. Заведите `.env`-файл с чувствительными данными на подобии `.env-example`.
3. Запуститите воркер:

```shell
python -m src.workers.autopayments.main
```

### Работа воркера в контейнере по расписанию

Так как воркер работает раз в сутки, необходимо настроить его работу по расписанию как запуск контейнера.

1. В первую очередь необходимо собрать образ для контейнера (единожды выполняется при развертывании системы):

```shell
docker build -t <наименование_образа> -f src/workers/autopayments/Dockerfile .
```
2. Если БД запущена в контейнере, необходимо получить наименование его сети:

```shell
docker inspect <наименование_контейнера_БД>
```

В выводе команды нас интересует блок _"Networks"_ и его значение (например, "bridge")

3. Выполнить запуск контейнера с воркером, указав параметр _network_, чтобы воркер увидел контейнер с БД (для теста):

```shell
docker run -d --network <наименование_сети_контейнера_БД> --name <наименование_контейнера> <наименование_созданного_образа> --rm
```

4. Настроить планировщик заданий, указав команду для запуска из п.3.

---
## Expire subscriptions worker

Воркер мониторинга подписок с истекщим сроком действия.

**Описание:**

Актуализация статуса подписок в случае истечения срока действия более чем на 3 дня от текущей даты.

**Периодичность:**

Раз в сутки по расписанию через **CRON**

**Логика:**

* выполнить выгрузку активных подписок из БД (сущность *"Subscription"*), у которых дата окончания действия (поле *"ended_at"*) <= [текущая дата - 3 дня];
* если подписки по такому условию найдены - обновить каждую подписку, присвоив ей статус *"EXPIRED"*.

### Как запустить воркер

**Важно!**
Для работы воркера должен быть установлен и запущен экземпляр БД (локально или в контейнере)

1. Установите необходимые библиотеки:

```shell
pip install -r requirements.txt
```

2. Заведите `.env`-файл с чувствительными данными на подобии `.env-example`.
3. Запуститите воркер:

```shell
python -m src.workers.expire_subscriptions.main
```

### Работа воркера в контейнере по расписанию

Так как воркер работает раз в сутки, необходимо настроить его работу по расписанию как запуск контейнера.

1. В первую очередь необходимо собрать образ для контейнера (единожды выполняется при развертывании системы):

```shell
docker build -t <наименование_образа> -f src/workers/expire_subscriptions/Dockerfile .
```
2. Если БД запущена в контейнере, необходимо получить наименование его сети:

```shell
docker inspect <наименование_контейнера_БД>
```

В выводе команды нас интересует блок _"Networks"_ и его значение (например, "bridge")

3. Выполнить запуск контейнера с воркером, указав параметр _network_, чтобы воркер увидел контейнер с БД (для теста):

```shell
docker run -d --network <наименование_сети_контейнера_БД> --name <наименование_контейнера> <наименование_созданного_образа> --rm
```

4. Настроить планировщик заданий, указав команду для запуска из п.3.

---

## Expire payments worker

Воркер мониторинга платежей, которые более n-дней находятся в статусе *"PENDING"*.

**Описание:**

Актуализация статуса платежей в случае, если они находятся в статусе *"PENDING"* более n-дней (настраиваемый параметр, в нашей системе он равен **7**).

**Периодичность:**

Раз в сутки по расписанию через **CRON**

**Логика:**

* выполнить выгрузку платежей в статусе *"PENDING"* из БД (сущность *"Payment"*), у которых дата создания (поле *"created_at"*) < текущая дата;
* если разница между датой создания платежа и текущей датой более заданных n-дней, платеж переводится в статус *"EXPIRED"*.

### Как запустить воркер

**Важно!**
Для работы воркера должен быть установлен и запущен экземпляр БД (локально или в контейнере)

1. Установите необходимые библиотеки:

```shell
pip install -r requirements.txt
```

2. Заведите `.env`-файл с чувствительными данными на подобии `.env-example`.
3. Запуститите воркер:

```shell
python -m src.workers.matching_expire_payments.main
```

### Работа воркера в контейнере по расписанию

Так как воркер работает раз в сутки, необходимо настроить его работу по расписанию как запуск контейнера.

1. В первую очередь необходимо собрать образ для контейнера (единожды выполняется при развертывании системы):

```shell
docker build -t <наименование_образа> -f src/workers/matching_expire_payments/Dockerfile .
```
2. Если БД запущена в контейнере, необходимо получить наименование его сети:

```shell
docker inspect <наименование_контейнера_БД>
```

В выводе команды нас интересует блок _"Networks"_ и его значение (например, "bridge")

3. Выполнить запуск контейнера с воркером, указав параметр _network_, чтобы воркер увидел контейнер с БД (для теста):

```shell
docker run -d --network <наименование_сети_контейнера_БД> --name <наименование_контейнера> <наименование_созданного_образа> --rm
```

4. Настроить планировщик заданий, указав команду для запуска из п.3.

---

## Matching pending payments worker

Воркер мэтчинга платежей в БД и в провайдере.

**Описание:**

Актуализация платежей в случае, если они находятся в статусе *"PENDING"*, но в провайдере данный платеж находится в статусе *"SUCCEEDED"*; cоздание подписки.

**Периодичность:**

Каждые 2 минуты.

**Логика:**

* выполнить выгрузку платежей в статусе *"PENDING"* из БД (сущность *"Payment"*), у которых дата создания (поле *"created_at"*) <= текущая дата и >= [текущая дата - 1 час];
* выполнить выгрузку платежей в статусе *"SUCCEEDED"* из провайдера, у которых дата создания <= текущая дата и >= [текущая дата - 1 час];
* определить несоответсвие данных;
* если найдено несоответствие - создать подписку в БД (сущность *"Subscription"*), обновить платеж в БД (сущность *"Payment"*).

### Как запустить воркер

**Важно!**
Для работы воркера должен быть установлен и запущен экземпляр БД (локально или в контейнере)

1. Установите необходимые библиотеки:

```shell
pip install -r requirements.txt
```

2. Заведите `.env`-файл с чувствительными данными на подобии `.env-example`.
3. Запуститите воркер:

```shell
python -m src.workers.matching_pending_payments.main
```

### Работа воркера в контейнере по расписанию

Так как воркер работает раз в сутки, необходимо настроить его работу по расписанию как запуск контейнера.

1. В первую очередь необходимо собрать образ для контейнера (единожды выполняется при развертывании системы):

```shell
docker build -t <наименование_образа> -f src/workers/matching_pending_payments/Dockerfile .
```
2. Если БД запущена в контейнере, необходимо получить наименование его сети:

```shell
docker inspect <наименование_контейнера_БД>
```

В выводе команды нас интересует блок _"Networks"_ и его значение (например, "bridge")

3. Выполнить запуск контейнера с воркером, указав параметр _network_, чтобы воркер увидел контейнер с БД (для теста):

```shell
docker run -d --network <наименование_сети_контейнера_БД> --name <наименование_контейнера> <наименование_созданного_образа> --rm
```

4. Настроить планировщик заданий, указав команду для запуска из п.3.

---

## Matching successful payments worker

Воркер мэтчинга успешных платежей в БД и в провайдере.

**Описание:**

Создание подписок и платежей в случае, если в провайдере имеются платежи в статусе *"SUCCEEDED"*, но отсутствют в БД.

**Периодичность:**

Каждые 2 минуты.

**Логика:**

* выполнить выгрузку платежей в статусе *"SUCCEEDED"* из БД (сущность *"Payment"*), у которых дата создания (поле *"created_at"*) <= текущая дата и >= [текущая дата - 1 час];
* выполнить выгрузку платежей в статусе *"SUCCEEDED"* из провайдера, у которых дата создания <= текущая дата и >= [текущая дата - 1 час];
* определить несоответсвие данных;
* если найдено несоответствие - создать платеж в БД (сущность *"Payment"*), создать подписку в БД (сущность *"Subscription"*).

### Как запустить воркер

**Важно!**
Для работы воркера должен быть установлен и запущен экземпляр БД (локально или в контейнере)

1. Установите необходимые библиотеки:

```shell
pip install -r requirements.txt
```

2. Заведите `.env`-файл с чувствительными данными на подобии `.env-example`.
3. Запуститите воркер:

```shell
python -m src.workers.matching_successful_payments.main
```

### Работа воркера в контейнере по расписанию

Так как воркер работает раз в сутки, необходимо настроить его работу по расписанию как запуск контейнера.

1. В первую очередь необходимо собрать образ для контейнера (единожды выполняется при развертывании системы):

```shell
docker build -t <наименование_образа> -f src/workers/matching_successful_payments/Dockerfile .
```
2. Если БД запущена в контейнере, необходимо получить наименование его сети:

```shell
docker inspect <наименование_контейнера_БД>
```

В выводе команды нас интересует блок _"Networks"_ и его значение (например, "bridge")

3. Выполнить запуск контейнера с воркером, указав параметр _network_, чтобы воркер увидел контейнер с БД (для теста):

```shell
docker run -d --network <наименование_сети_контейнера_БД> --name <наименование_контейнера> <наименование_созданного_образа> --rm
```

4. Настроить планировщик заданий, указав команду для запуска из п.3.